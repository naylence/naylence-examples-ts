# Crash Recovery: Agent Reprocessing Messages

This example demonstrates Naylence's ability to **recover from agent crashes** and **automatically reprocess unhandled messages** — a core feature of the delivery system.

Normally, acknowledgments (`ACKs`) are issued _before_ an agent finishes handling a message. If the agent crashes mid-processing, the framework ensures the message is not lost. With **at-least-once delivery mode** and a **durable store** enabled, the unprocessed message is preserved and retried when the agent restarts.

⚠️ **Important:** This example requires both:

- **At-least-once delivery mode** enabled via `FAME_DELIVERY_PROFILE=at-least-once`.
- A **durable storage backend** (e.g., SQLite). The default in-memory store will _not_ persist messages across restarts.

Agent persistence is enabled in `config/.env.agent` using the following variables:

```
FAME_DELIVERY_PROFILE=at-least-once
FAME_STORAGE_PROFILE=encrypted-sqlite
FAME_STORAGE_MASTER_KEY=<your_master_key>
FAME_STORAGE_DB_DIRECTORY=/work/data/agent
```

---

## What's inside

- **Sentinel** — coordination node that manages message routing.
- **MessageAgent** — stateful agent with a counter:
  - On each message, it increments the counter (persisted in agent state).
  - On **odd counts**, it simulates a crash (`process.exit(1)`).
  - On **even counts**, it processes the message successfully.

- **Client** — sends a simple message (`"Hello, World!"`).

Flow:

```
client ──▶ sentinel ──▶ message-agent
```

- Odd count → agent crashes mid-processing → Docker Compose restarts it.
- Restart → agent resumes with counter incremented → reprocesses same message successfully.

---

## Files

- `sentinel.ts` — starts the sentinel.
- `message-agent.ts` — agent with counter + crash simulation.
- `client.ts` — sends a message.
- `common.ts` — shared constants (agent address).
- `docker-compose.yml` — stack with auto-restart for the agent.
- `config/.env.agent.example` — template for delivery mode and durable storage configuration.
- `config/.env.client.example` — template for client configuration.
- `Makefile` — convenience targets (`init`, `start`, `run`, `stop`, etc.).

---

## Quick start

> Requirements: Docker + Docker Compose + Node.js 18+ installed.

1. **Initialize and build**

```bash
make init    # installs dependencies and generates config files
make build   # compiles TypeScript to JavaScript
```

Or run both steps with:

```bash
make start   # runs init, build, and starts services
```

2. **Send a message (simulate crash & recovery)**

```bash
make run
```

What happens:

- Client sends `"Hello, World!"`.
- Agent receives message, increments counter → odd count.
- Agent simulates crash → container exits.
- Docker Compose restarts agent.
- Agent resumes with counter incremented → reprocesses the _same_ message successfully.

Logs will show both the crash and the eventual successful processing.

3. **Stop everything**

```bash
make stop
```

---

## Expected output

Client:

```
Sending message to MessageAgent...
Acknowledgment received: DeliveryAck { ok: true, ... }
```

Logs (`make run` shows them automatically):

```
MessageAgent current state: 0
MessageAgent simulating crash while processing message...
... container restarts ...
MessageAgent current state: 1
MessageAgent processed message successfully: Hello, World!
```

---

## How it works

- **Pre-handle ACKs:** Naylence issues delivery acks before agent code executes. If the agent dies mid-task, the ack is not the end of the story.
- **At-least-once delivery:** Enabled via `FAME_DELIVERY_PROFILE=at-least-once`, ensures messages are retried if they weren't fully processed.
- **Durable state:** Because the agent state (counter) and pending messages are in a persistent store, they survive restarts.
- **Recovery:** Upon restart, the agent automatically retries the unprocessed message. From the client's perspective, delivery remains **at-least-once**.

---

## Additional commands

### View live logs

```bash
make logs    # tail message-agent logs (Ctrl+C to stop)
```

### Run with verbose envelope logging

```bash
make run-verbose    # shows detailed envelope traffic
```

### Clean everything

```bash
make clean    # stops services, removes build artifacts, data, and config files
```

---

## Configuration details

The example uses two environment files:

**`config/.env.agent`** (generated from `.env.agent.example`):

```bash
FAME_DIRECT_ADMISSION_URL=ws://sentinel:8000/fame/v1/attach/ws/downstream
FAME_DELIVERY_PROFILE=at-least-once
FAME_STORAGE_PROFILE=encrypted-sqlite
FAME_STORAGE_MASTER_KEY=<generated-master-key>
FAME_STORAGE_DB_DIRECTORY=/work/data/agent
FAME_PLUGINS=@naylence/runtime,@naylence/agent-sdk
FAME_SHOW_ENVELOPES=true
```

**`config/.env.client`** (generated from `.env.client.example`):

```bash
FAME_DIRECT_ADMISSION_URL=ws://localhost:8000/fame/v1/attach/ws/upstream
```

These files are automatically generated by `make init` using the `generate-secrets.mjs` script.

---

## Troubleshooting

- **Agent doesn't reprocess after crash** → check `config/.env.agent` to confirm both at-least-once delivery and durable storage are configured:

  ```
  FAME_DELIVERY_PROFILE=at-least-once
  FAME_STORAGE_PROFILE=encrypted-sqlite
  FAME_STORAGE_MASTER_KEY=<your_master_key>
  FAME_STORAGE_DB_DIRECTORY=/work/data/agent
  ```

- **Client hangs** → ensure sentinel is healthy (`docker ps` should show `sentinel` up).
- **Repeated crashes** → expected on odd counts; try sending multiple messages to see alternating crash/success behavior.
- **Missing config files** → run `make init` to generate `.env.agent` and `.env.client` from templates.
- **Build errors** → ensure Node.js 18+ is installed and dependencies are installed (`npm install`).
- **Permission errors with data directory** → ensure the `data/agent` directory exists and is writable.

---

## Code comparison: Python vs TypeScript

Key differences in the implementation:

| Python                     | TypeScript                  | Notes                              |
| -------------------------- | --------------------------- | ---------------------------------- |
| `sys.exit(1)`              | `process.exit(1)`           | Exit process to simulate crash     |
| `on_message`               | `onMessage`                 | CamelCase for method names         |
| Agent state access         | `await this.withState(...)` | TypeScript uses async state access |
| Pydantic models            | Zod schemas + classes       | Schema validation approach         |
| `BaseAgentState` extension | `extends BaseAgentState`    | State model definition             |

---

## Next steps

- Try sending multiple messages to observe the alternating crash/success pattern.
- Modify the crash condition (e.g., crash on every 3rd message instead of odd counts).
- Explore the persisted state in `data/agent/` to see how the counter is stored.
- Compare with the `retry-on-no-ack-received` example for different delivery semantics.
- Integrate this pattern into your own agents that need guaranteed message processing.

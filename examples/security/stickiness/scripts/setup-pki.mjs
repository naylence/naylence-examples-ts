#!/usr/bin/env node

import { mkdir, writeFile } from "fs/promises";
import { existsSync } from "fs";
import { join, resolve } from "path";
import { fileURLToPath } from "url";
import { webcrypto } from "crypto";

import { CASigningService, createTestCA } from "@naylence/advanced-security";

const { crypto } = globalThis;
if (!crypto || !crypto.subtle) {
  globalThis.crypto = webcrypto;
}

const subtle = globalThis.crypto.subtle;

function parseArgs() {
  const args = process.argv.slice(2);
  let output = "./config/certs";
  let org = "Naylence Development";
  const logicals = [];

  for (let i = 0; i < args.length; i += 1) {
    const arg = args[i];
    if (arg === "--output" && i + 1 < args.length) {
      output = args[i + 1];
      i += 1;
    } else if (arg === "--org" && i + 1 < args.length) {
      org = args[i + 1];
      i += 1;
    } else if ((arg === "--logical" || arg === "--logicals") && i + 1 < args.length) {
      logicals.push(args[i + 1]);
      i += 1;
    }
  }

  return {
    output,
    org,
    logicals,
  };
}

function formatPem(base64) {
  const lines = [];
  for (let i = 0; i < base64.length; i += 64) {
    lines.push(base64.slice(i, i + 64));
  }
  return lines.join("\n");
}

function bufferToPem(buffer, label) {
  const base64 = Buffer.from(buffer).toString("base64");
  return `-----BEGIN ${label}-----\n${formatPem(base64)}\n-----END ${label}-----\n`;
}

async function generateEd25519KeyPair() {
  const keyPair = await subtle.generateKey(
    {
      name: "Ed25519",
      namedCurve: "Ed25519",
    },
    true,
    ["sign", "verify"]
  );

  const privateKeyDer = await subtle.exportKey("pkcs8", keyPair.privateKey);
  const publicKeyDer = await subtle.exportKey("spki", keyPair.publicKey);

  return {
    privateKeyPem: bufferToPem(privateKeyDer, "PRIVATE KEY"),
    publicKeyPem: bufferToPem(publicKeyDer, "PUBLIC KEY"),
  };
}

function normalizeLogicals(logicals) {
  if (!logicals || logicals.length === 0) {
    return [process.env.FAME_ROOT ?? "fame.fabric"];
  }

  return logicals.map((logical) => {
    if (!logical.startsWith("/")) {
      return logical;
    }

    if (logical === "/") {
      return process.env.FAME_ROOT ?? "fame.fabric";
    }

    const parts = logical
      .split("/")
      .filter(Boolean)
      .reverse();

    const host = parts.join(".");
    return host.endsWith(".fabric") ? host : `${host}.fabric`;
  });
}

async function writeFileUtf8(path, contents) {
  await writeFile(path, contents, "utf8");
}

async function setupPKI({ output, org, logicals }) {
  const outputDir = resolve(output);
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  console.log(`Generating PKI hierarchy in ${outputDir}`);
  console.log(`Organization: ${org}`);

  const normalizedLogicals = normalizeLogicals(logicals);
  console.log(`Logical hosts: ${normalizedLogicals.join(", ")}`);

  const [rootCertPem, rootKeyPem] = await createTestCA();

  const rootCertPath = join(outputDir, "root-ca.crt");
  const rootKeyPath = join(outputDir, "root-ca.key");

  await writeFileUtf8(rootCertPath, rootCertPem);
  await writeFileUtf8(rootKeyPath, rootKeyPem);

  console.log("Root CA material generated");

  const caService = new CASigningService({
    rootCertPem,
    rootKeyPem,
  });

  const intermediateKeys = await generateEd25519KeyPair();
  const intermediateCertPem = await caService.createIntermediateCA(
    intermediateKeys.publicKeyPem,
    `${org} Intermediate CA`,
    normalizedLogicals,
    1825
  );

  const intermediateCertPath = join(outputDir, "intermediate-ca.crt");
  const intermediateKeyPath = join(outputDir, "intermediate-ca.key");
  await writeFileUtf8(intermediateCertPath, intermediateCertPem);
  await writeFileUtf8(intermediateKeyPath, intermediateKeys.privateKeyPem);

  const intermediateChainPem = `${intermediateCertPem}`;
  const completeChainPem = `${intermediateCertPem}\n${rootCertPem}`;

  await writeFileUtf8(join(outputDir, "intermediate-chain.crt"), intermediateChainPem);
  await writeFileUtf8(join(outputDir, "complete-chain.crt"), completeChainPem);

  const envPath = join(outputDir, "fame-ca.env");
  const envContent = [
    "# Generated by setup-pki.mjs",
    `export FAME_CA_CERTS="${rootCertPath}"`,
    `export FAME_CA_CERT_FILE="${rootCertPath}"`,
    `export FAME_CA_KEY_FILE="${rootKeyPath}"`,
    `export FAME_INTERMEDIATE_CHAIN_FILE="${join(outputDir, "intermediate-chain.crt")}"`,
    `export FAME_SIGNING_CERT_FILE="${intermediateCertPath}"`,
    `export FAME_SIGNING_KEY_FILE="${intermediateKeyPath}"`,
    `export FAME_ROOT_CA_FOR_VERIFICATION="${rootCertPath}"`,
    `export FAME_COMPLETE_CHAIN_FILE="${join(outputDir, "complete-chain.crt")}"`,
    "echo \"Fame CA environment configured.\"",
    "",
  ].join("\n");

  await writeFileUtf8(envPath, envContent);

  const readmePath = join(outputDir, "README.md");
  const readmeLines = [
    `# Naylence PKI Setup - ${org}`,
    "",
    "This directory contains locally generated PKI artifacts for Naylence Fame.",
    "",
    "## Files",
    "",
    "- `root-ca.crt` / `root-ca.key`: Root certificate authority (keep the key secure).",
    "- `intermediate-ca.crt` / `intermediate-ca.key`: Intermediate CA used for signing leaf certificates.",
    "- `intermediate-chain.crt`: Chain containing the intermediate CA.",
    "- `complete-chain.crt`: Intermediate chain plus root CA for verifiers.",
    "- `fame-ca.env`: Convenience environment variables for the Fame CA service.",
    "",
    "## Usage",
    "",
    `source ${envPath}`,
    "",
    "Then start the Fame CA service or runtime components that rely on these credentials.",
    "",
    "## Logical Hosts",
    "",
    ...normalizedLogicals.map((logical) => `- ${logical}`),
    "",
  ].join("\n");

  await writeFileUtf8(readmePath, readmeLines);

  console.log("Intermediate CA material generated");
  console.log(`Root certificate: ${rootCertPath}`);
  console.log(`Root key: ${rootKeyPath}`);
  console.log(`Intermediate certificate: ${intermediateCertPath}`);
  console.log(`Intermediate key: ${intermediateKeyPath}`);
  console.log(`Environment file: ${envPath}`);
  console.log(`README: ${readmePath}`);
}

const options = parseArgs();
const scriptDir = resolve(fileURLToPath(new URL(".", import.meta.url)));
if (process.cwd() !== scriptDir) {
  console.log(`Using setup script from ${scriptDir}`);
}

setupPKI(options).catch((error) => {
  console.error("PKI setup failed:", error);
  process.exitCode = 1;
});
